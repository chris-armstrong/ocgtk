(* GTK4 Event Controller Specifications *)
(* This file defines event controllers and their signals/methods *)
(* The controllercc tool generates C and OCaml bindings from this *)

prefix "Gtk"
c_prefix "gtk"

(* Type mappings for signal parameters *)
types {
  guint -> "int" "Int_val" "Val_int"
  gint -> "int" "Int_val" "Val_int"
  gdouble -> "float" "Double_val" "caml_copy_double"
  gboolean -> "bool" "Bool_val" "Val_bool"
  gchararray -> "string" "String_val" "caml_copy_string"
  GdkModifierType -> "Gdk.modifier_type list" "ModifierType_val" "Val_ModifierType"
  GdkEvent -> "Gdk.Event.t" "GdkEvent_val" "Val_GdkEvent"
  GtkIMContext -> "GtkIMContext.t" "GtkIMContext_val" "Val_GtkIMContext"
  GdkEventSequence -> "Gdk.event_sequence" "GdkEventSequence_val" "Val_GdkEventSequence"
}

(* Base event controller *)
class EventController abstract : GObject {
  (* Base methods available on all controllers *)
  method get_widget : GtkWidget option
  method get_propagation_phase : GtkPropagationPhase
  method set_propagation_phase : GtkPropagationPhase -> unit
  method get_propagation_limit : GtkPropagationLimit
  method set_propagation_limit : GtkPropagationLimit -> unit
  method reset : unit
  method get_current_event : GdkEvent option
  method get_current_event_device : GdkDevice option
  method get_current_event_time : guint
}

(* Keyboard events *)
class EventControllerKey : EventController {
  constructor new_

  (* Signals *)
  signal key_pressed : guint guint GdkModifierType -> gboolean {
    params ["keyval"; "keycode"; "state"]
    doc "Emitted when a key is pressed. Return true to stop propagation."
  }

  signal key_released : guint guint GdkModifierType -> unit {
    params ["keyval"; "keycode"; "state"]
    doc "Emitted when a key is released."
  }

  signal modifiers : GdkModifierType -> gboolean {
    params ["state"]
    doc "Emitted when modifier keys change. Return true to stop propagation."
  }

  (* Methods *)
  method forward : GdkEvent -> gboolean {
    doc "Forward the event to the input method context."
  }

  method get_im_context : GtkIMContext option {
    doc "Get the input method context, if any."
  }

  method set_im_context : GtkIMContext -> unit {
    doc "Set the input method context."
  }

  method get_group : guint {
    doc "Get the key group for the last processed event."
  }
}

(* Mouse motion events *)
class EventControllerMotion : EventController {
  constructor new_

  (* Signals *)
  signal enter : gdouble gdouble -> unit {
    params ["x"; "y"]
    doc "Emitted when the pointer enters the widget."
  }

  signal leave : unit {
    doc "Emitted when the pointer leaves the widget."
  }

  signal motion : gdouble gdouble -> unit {
    params ["x"; "y"]
    doc "Emitted when the pointer moves within the widget."
  }

  (* Methods *)
  method contains_pointer : gboolean {
    doc "Check if the pointer is currently over the widget."
  }

  method is_pointer : gboolean {
    doc "Check if the widget is receiving pointer events."
  }
}

(* Focus events *)
class EventControllerFocus : EventController {
  constructor new_

  signal enter : unit {
    doc "Emitted when focus enters the widget."
  }

  signal leave : unit {
    doc "Emitted when focus leaves the widget."
  }

  method contains_focus : gboolean {
    doc "Check if the widget or a child has focus."
  }

  method is_focus : gboolean {
    doc "Check if the widget itself has focus."
  }
}

(* Scrolling events *)
class EventControllerScroll : EventController {
  constructor new_ : GtkEventControllerScrollFlags

  signal scroll_begin : unit {
    doc "Emitted when scrolling starts."
  }

  signal scroll : gdouble gdouble -> gboolean {
    params ["dx"; "dy"]
    doc "Emitted when scrolling. Return true to stop propagation."
  }

  signal scroll_end : unit {
    doc "Emitted when scrolling ends."
  }

  signal decelerate : gdouble gdouble -> unit {
    params ["vel_x"; "vel_y"]
    doc "Emitted at the end of scroll with deceleration velocity."
  }

  method get_flags : GtkEventControllerScrollFlags
  method set_flags : GtkEventControllerScrollFlags -> unit
}

(* Base gesture recognizer *)
class Gesture abstract : EventController {
  method get_device : GdkDevice option
  method set_state : GtkEventSequence -> GtkEventState -> gboolean
  method get_sequence_state : GtkEventSequence -> GtkEventState
  method set_sequence_state : GtkEventSequence GtkEventState -> gboolean
  method is_active : gboolean
  method is_recognized : gboolean
  method handles_sequence : GtkEventSequence -> gboolean

  signal begin : GdkEventSequence option -> unit {
    params ["sequence"]
  }
  signal end : GdkEventSequence option -> unit {
    params ["sequence"]
  }
  signal update : GdkEventSequence option -> unit {
    params ["sequence"]
  }
  signal cancel : GdkEventSequence option -> unit {
    params ["sequence"]
  }
  signal sequence_state_changed : GdkEventSequence GtkEventState -> unit {
    params ["sequence"; "state"]
  }
}

(* Single-point gestures *)
class GestureSingle abstract : Gesture {
  method get_exclusive : gboolean
  method set_exclusive : gboolean -> unit
  method get_touch_only : gboolean
  method set_touch_only : gboolean -> unit
  method get_button : guint
  method set_button : guint -> unit
  method get_current_button : guint
  method get_current_sequence : GdkEventSequence option
}

(* Click/button press gesture *)
class GestureClick : GestureSingle {
  constructor new_

  signal pressed : gint gdouble gdouble -> unit {
    params ["n_press"; "x"; "y"]
    doc "Emitted when a button is pressed. n_press is click count."
  }

  signal released : gint gdouble gdouble -> unit {
    params ["n_press"; "x"; "y"]
    doc "Emitted when a button is released."
  }

  signal stopped : unit {
    doc "Emitted when the gesture is recognized as stopped."
  }

  signal unpaired_release : gdouble gdouble guint GdkEventSequence option -> unit {
    params ["x"; "y"; "button"; "sequence"]
    doc "Emitted when a release happens without matching press (drag started)."
  }
}

(* Drag gesture *)
class GestureDrag : GestureSingle {
  constructor new_

  signal drag_begin : gdouble gdouble -> unit {
    params ["start_x"; "start_y"]
  }

  signal drag_update : gdouble gdouble -> unit {
    params ["offset_x"; "offset_y"]
  }

  signal drag_end : gdouble gdouble -> unit {
    params ["offset_x"; "offset_y"]
  }

  method get_start_point : gdouble* gdouble* -> gboolean {
    out_params ["x"; "y"]
  }

  method get_offset : gdouble* gdouble* -> gboolean {
    out_params ["x"; "y"]
  }
}

(* Long press gesture *)
class GestureLongPress : GestureSingle {
  constructor new_

  signal pressed : gdouble gdouble -> unit {
    params ["x"; "y"]
  }

  signal cancelled : unit

  method set_delay_factor : gdouble -> unit
  method get_delay_factor : gdouble
}

(* Swipe gesture *)
class GestureSwipe : Gesture {
  constructor new_

  signal swipe : gdouble gdouble -> unit {
    params ["velocity_x"; "velocity_y"]
  }

  method get_velocity : gdouble* gdouble* -> gboolean {
    out_params ["velocity_x"; "velocity_y"]
  }
}

(* Zoom gesture *)
class GestureZoom : Gesture {
  constructor new_

  signal scale_changed : gdouble -> unit {
    params ["scale"]
  }

  method get_scale_delta : gdouble
}

(* Rotate gesture *)
class GestureRotate : Gesture {
  constructor new_

  signal angle_changed : gdouble gdouble -> unit {
    params ["angle"; "angle_delta"]
  }

  method get_angle_delta : gdouble
}

(* Stylus events *)
class GestureStylus : GestureSingle {
  constructor new_

  signal proximity : gdouble gdouble -> unit {
    params ["x"; "y"]
  }

  signal down : gdouble gdouble -> unit {
    params ["x"; "y"]
  }

  signal motion : gdouble gdouble -> unit {
    params ["x"; "y"]
  }

  signal up : gdouble gdouble -> unit {
    params ["x"; "y"]
  }

  method get_axis : GdkAxisUse -> gdouble* -> gboolean {
    out_params ["value"]
  }

  method get_axes : GdkAxisUse* gdouble** -> gboolean {
    out_params ["axes"; "values"]
  }

  method get_backlog : GdkTimeCoord** guint* -> gboolean {
    out_params ["backlog"; "n_elems"]
  }

  method get_device_tool : GdkDeviceTool option
}

(* Legacy event access *)
class EventControllerLegacy : EventController {
  constructor new_

  signal event : GdkEvent -> gboolean {
    params ["event"]
    doc "Emitted for any GdkEvent. Return true to stop propagation."
  }
}
