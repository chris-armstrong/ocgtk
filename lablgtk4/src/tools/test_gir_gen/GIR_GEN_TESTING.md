# GIR Generator Testing Documentation

This document provides comprehensive documentation on the testing strategy, infrastructure, and organization for the lablgtk4 GIR generator.

## Table of Contents

1. [Overview](#overview)
2. [Architecture & Generation Layers](#architecture--generation-layers)
3. [Testing Infrastructure](#testing-infrastructure)
4. [Test Organization & Directory Structure](#test-organization--directory-structure)
5. [Layer 0: C Stub Generation Tests](#layer-0-c-stub-generation-tests)
6. [Layer 1: ML File Generation Tests](#layer-1-ml-file-generation-tests)
7. [Layer 2: Class Generation Tests](#layer-2-class-generation-tests)
8. [Integration Tests](#integration-tests)
9. [Writing New Tests](#writing-new-tests)
10. [Test Results & Coverage](#test-results--coverage)
11. [Future Extensions](#future-extensions)

---

## Overview

The lablgtk4 GIR generator produces OCaml bindings from GObject Introspection (GIR) XML files. The generator operates in multiple layers, each requiring its own testing strategy:

- **Layer 0: C Stub Generation** - Low-level C FFI stubs that interface between OCaml and GTK's C API
- **Layer 1: ML File Generation** - OCaml interface files (.ml/.mli) with type definitions and function signatures
- **Layer 2: Class Generation** - High-level OCaml class wrappers with object-oriented interfaces
- **Integration** - Full pipeline testing that validates all layers working together

### Key Testing Goals

1. **Validate generated code** at each layer without requiring a full compilation
2. **Test type conversions** between OCaml, C, and GObject types
3. **Ensure correct parameter handling** for various scenarios (nullable, out params, errors, etc.)
4. **Verify structural correctness** of generated functions, types, and classes
5. **Catch regressions** early in the development cycle

---

## Architecture & Generation Layers

The GIR generator follows a layered architecture:

```
GIR XML Input
     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Layer 0: C Stub Generation             ‚îÇ
‚îÇ  - C FFI stubs (*.c files)              ‚îÇ
‚îÇ  - Type conversions (Val_GtkXxx macros) ‚îÇ
‚îÇ  - Parameter marshalling                ‚îÇ
‚îÇ  - Error handling (GError)              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Layer 1: ML File Generation            ‚îÇ
‚îÇ  - OCaml interfaces (*.ml/*.mli)        ‚îÇ
‚îÇ  - Type definitions                     ‚îÇ
‚îÇ  - External declarations                ‚îÇ
‚îÇ  - Module structure                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Layer 2: Class Generation              ‚îÇ
‚îÇ  - Object-oriented wrappers             ‚îÇ
‚îÇ  - Inheritance hierarchy                ‚îÇ
‚îÇ  - Method dispatch                      ‚îÇ
‚îÇ  - Property accessors                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Each layer builds upon the previous layer and requires different testing approaches.

---

## Testing Infrastructure

### C Parser Implementation

The C parser is implemented in `c_parser.ml` and provides:

- **Lexical analysis** - Tokenizes C code into basic elements
- **Syntactic analysis** - Builds an AST from tokens
- **Pattern matching** - Focuses on common C stub patterns rather than full C99 compliance

#### Parser Capabilities

‚úÖ **Supported:**
- Function declarations and definitions
- Variable declarations with initialization
- Function calls
- Return statements
- Assignment statements
- Conditional statements (if/else) - **single-line only**
- Type casting
- Pointer and reference operators
- Macro calls (e.g., `Val_GtkWidget`, `String_val`)

‚ùå **Limitations:**
- Multi-line if/else statements not supported
- Complex control flow (switch, while, for)
- Struct/enum/typedef declarations
- Preprocessor directives (except basic macro calls)

#### Parser Design Philosophy

The parser is **purposefully lightweight** and targets the specific patterns generated by the GIR stub generator. It's not a full C parser, but rather a **domain-specific parser** for validating generated stubs.

Example of what it parses well:

```c
CAMLprim value ml_gtk_button_new(value unit) {
    GtkButton *obj = gtk_button_new();
    return Val_GtkButton(obj);
}
```

### AST Structure

Core AST types are defined in `c_ast.ml`:

```ocaml
type c_type = string

type c_expr =
  | Var of string
  | Call of string * c_expr list
  | IntLit of int
  | StringLit of string
  | Cast of c_type * c_expr
  | UnOp of string * c_expr      (* &x, *x *)
  | BinOp of c_expr * string * c_expr
  | Macro of string * c_expr list
  | Null
  | Ternary of c_expr * c_expr * c_expr

type c_stmt =
  | VarDecl of string * c_type * c_expr option
  | Assign of string * c_expr
  | Call_stmt of string * c_expr list
  | Return of c_expr
  | If of c_expr * c_stmt list * c_stmt list option
  | Expr of c_expr

type c_function = {
  name : string;
  return_type : c_type;
  params : (string * c_type) list;
  body : c_stmt list;
}
```

#### AST Inspection Functions

The `c_ast.ml` module provides helper functions:

- `find_function` - Locate a function by name
- `get_param_count` - Count function parameters
- `get_var_decls` - Extract variable declarations
- `has_return_stmt` - Check for return statements
- `expr_uses_var` - Determine if an expression uses a variable
- `extract_type_info` - Extract type conversion information

### ML Parser Implementation

**TODO: Document ML parser for Layer 1 testing**

### Helper Modules

#### helpers.ml

Provides:
- `create_test_context()` - Creates minimal generation context
- `wrap_namespace()` - Wraps XML content in GIR boilerplate
- `create_gir_file()` - Writes GIR XML to file
- `run_gir_gen()` - Executes main.exe with logging
- File path utilities (`stub_c_file`, `mli_file`, etc.)
- Assertion helpers (`assert_true`, `assert_contains`, etc.)

#### c_validation.ml

Higher-level validation functions:
- `validates_gtk_constructor()` - Checks for proper Val_GtkXxx usage
- `calls_c_function()` - Verifies C function is called
- `validates_bytecode_native_pair()` - Checks bytecode/native wrapper pair

---

## Test Organization & Directory Structure

### Proposed Directory Structure

Tests will be organized into subdirectories by layer and test type:

```
src/tools/test_gir_gen/
‚îú‚îÄ‚îÄ test_gir_gen.ml              # Main test runner
‚îú‚îÄ‚îÄ GIR_GEN_TESTING.md           # This document
‚îú‚îÄ‚îÄ FAILING_TESTS_ANALYSIS.md    # Analysis of known failures
‚îÇ
‚îú‚îÄ‚îÄ infrastructure/              # Shared testing infrastructure
‚îÇ   ‚îú‚îÄ‚îÄ helpers.ml               # Shared test utilities
‚îÇ   ‚îú‚îÄ‚îÄ c_parser.ml              # C code parser
‚îÇ   ‚îú‚îÄ‚îÄ c_ast.ml                 # C AST types and inspection
‚îÇ   ‚îú‚îÄ‚îÄ c_validation.ml          # C validation helpers
‚îÇ   ‚îú‚îÄ‚îÄ ml_parser.ml             # ML code parser (TODO)
‚îÇ   ‚îú‚îÄ‚îÄ ml_ast.ml                # ML AST types (TODO)
‚îÇ   ‚îî‚îÄ‚îÄ ml_validation.ml         # ML validation helpers (TODO)
‚îÇ
‚îú‚îÄ‚îÄ c_stubs/                     # Layer 0: C Stub Generation Tests
‚îÇ   ‚îú‚îÄ‚îÄ c_stubs_tests.ml         # Basic constructor/method generation
‚îÇ   ‚îú‚îÄ‚îÄ nullable_tests.ml        # Nullable parameter handling
‚îÇ   ‚îú‚îÄ‚îÄ error_handling_tests.ml  # GError handling (throws=true)
‚îÇ   ‚îú‚îÄ‚îÄ out_params_tests.ml      # Out and InOut parameters
‚îÇ   ‚îú‚îÄ‚îÄ type_conversion_tests.ml # Type conversions
‚îÇ   ‚îî‚îÄ‚îÄ edge_cases.ml            # Edge cases and boundaries
‚îÇ
‚îú‚îÄ‚îÄ ml_generation/               # Layer 1: ML File Generation Tests (TODO)
‚îÇ   ‚îú‚îÄ‚îÄ module_structure_tests.ml    # Module organization (TODO)
‚îÇ   ‚îú‚îÄ‚îÄ type_definition_tests.ml     # Type definitions (TODO)
‚îÇ   ‚îú‚îÄ‚îÄ external_decl_tests.ml       # External declarations (TODO)
‚îÇ   ‚îú‚îÄ‚îÄ signature_tests.ml           # .mli signature generation (TODO)
‚îÇ   ‚îî‚îÄ‚îÄ edge_cases.ml                # ML-specific edge cases (TODO)
‚îÇ
‚îú‚îÄ‚îÄ class_generation/            # Layer 2: Class Generation Tests (TODO)
‚îÇ   ‚îú‚îÄ‚îÄ class_structure_tests.ml     # Class definitions (TODO)
‚îÇ   ‚îú‚îÄ‚îÄ inheritance_tests.ml         # Inheritance hierarchy (TODO)
‚îÇ   ‚îú‚îÄ‚îÄ method_dispatch_tests.ml     # Method dispatch (TODO)
‚îÇ   ‚îú‚îÄ‚îÄ property_accessor_tests.ml   # Property accessors (TODO)
‚îÇ   ‚îî‚îÄ‚îÄ edge_cases.ml                # Class-specific edge cases (TODO)
‚îÇ
‚îî‚îÄ‚îÄ integration/                 # Full pipeline integration tests
    ‚îú‚îÄ‚îÄ properties.ml            # Property getter/setter generation
    ‚îú‚îÄ‚îÄ signals.ml               # Signal handling generation
    ‚îú‚îÄ‚îÄ enums.ml                 # Enum and bitfield generation
    ‚îú‚îÄ‚îÄ records.ml               # Record type support
    ‚îî‚îÄ‚îÄ core.ml                  # Core integration tests
```

### Test Strategy by Directory

#### infrastructure/
Shared testing utilities used across all test suites. No test cases here, only helpers and parsers.

#### c_stubs/
**Current Implementation - Layer 0**

Unit tests for C stub generation using library-based testing:
- Call generator functions directly (e.g., `Generate.C_stubs.generate_c_method`)
- Parse generated C code with lightweight parser
- Validate AST structure and contents
- Fast execution, no file I/O

#### ml_generation/
**TODO - Layer 1**

Unit tests for ML file generation:
- Call ML generator functions directly
- Parse generated .ml and .mli files
- Validate module structure, type definitions, and signatures
- Verify external declarations match C stubs

#### class_generation/
**TODO - Layer 2**

Unit tests for class generation:
- Call class generator functions directly
- Parse generated class definitions
- Validate inheritance relationships
- Verify method dispatch and property accessors

#### integration/
End-to-end tests that validate the full pipeline:
- Generate complete GIR XML files
- Run main.exe to produce complete output
- Validate all generated files (.ml, .mli, .c)
- Slower but tests full integration

---

## Layer 0: C Stub Generation Tests

**Status: ‚úÖ IMPLEMENTED**

**Location:** `c_stubs/`

### Testing Approach

C stub tests use **library-based testing** for fast, focused unit tests:

1. Create test context and GIR data structures
2. Call `Generate.C_stubs.generate_c_method` or similar functions directly
3. Parse generated C code with lightweight C parser
4. Validate AST structure using inspection functions

**Example:**
```ocaml
let test_simple_method () =
  let ctx = Helpers.create_test_context () in
  let meth = { method_name = "set_label"; ... } in

  let c_code = Gir_gen_lib.Generate.C_stubs.generate_c_method
    ~ctx ~c_type:"GtkButton" meth "Button" in

  let functions = C_parser.parse_c_code c_code in
  assert_function_exists functions "ml_gtk_button_set_label"
```

### Test Coverage

**Total: 85 tests, 100% passing ‚úì**

#### Test Files

- `c_stubs_tests.ml` - Basic constructor and method generation, record types (16/16 passing)
- `nullable_tests.ml` - Nullable parameter and return value handling (5/5 passing)
- `error_handling_tests.ml` - Error handling (throws=true) (6/6 passing)
- `out_params_tests.ml` - Out and InOut parameter handling (6/6 passing)
- `type_conversion_tests.ml` - Various type conversions (9/9 passing)
- `edge_cases.ml` - Boundary conditions (2/2 passing)

#### Coverage Areas

‚úÖ **Completed:**
- Constructor generation (simple, with params, 6+ params)
- Method generation (void return, with return value)
- Type conversions (gboolean, gint, gdouble, utf8, objects, enums)
- Nullable parameters and return values
- GError handling (throws=true)
- Out and InOut parameters
- Record types (opaque and non-opaque)
- Nullable record types
- Bytecode/native function splits

‚ùå **Gaps:**
- Static methods (no self parameter)
- Varargs handling
- Default parameter values
- Transfer ownership annotations
- Callback parameters
- Array length parameters

### Test Results Summary

**All tests passing ‚úì**

See detailed test checklist in [Test Results & Coverage](#test-results--coverage) section.

---

## Layer 1: ML File Generation Tests

**Status: üöß IN PROGRESS**

**Location:** `ml_generation/` (to be created)

### Testing Approach

ML file generation tests use **library-based testing with OCaml AST** instead of string matching:

1. Create test context and GIR data structures
2. Call ML generator functions directly
3. **Parse generated .ml and .mli files using OCaml's built-in compiler-libs (`Parsetree`, `Parse`)**
4. **Validate module structure, type definitions, and signatures using AST inspection**
5. **Perform structural validation that survives formatting changes**

**Why OCaml AST Instead of String Matching:**
- ‚úÖ **No custom parser needed** - Uses OCaml's built-in `compiler-libs`
- ‚úÖ **Structural validation** - Validates actual OCaml syntax, not just text patterns
- ‚úÖ **Type-safe testing** - Leverages OCaml's type system for test assertions
- ‚úÖ **Refactoring-friendly** - Tests remain valid even if formatting changes
- ‚úÖ **Precise queries** - Can inspect specific AST nodes (type declarations, externals, etc.)
- ‚úÖ **Better error messages** - OCaml parser provides syntax error locations

### Proposed Test Organization

#### module_structure_tests.ml
**TODO:** Test ML module organization and structure

Coverage areas:
- [ ] Module naming conventions
- [ ] Module hierarchy (nested modules)
- [ ] Module signature constraints
- [ ] Module includes and opens
- [ ] Namespace mapping from GIR to OCaml modules

#### type_definition_tests.ml
**TODO:** Test OCaml type definitions

Coverage areas:
- [ ] Primitive type mappings
- [ ] Record type definitions
- [ ] Variant type definitions (enums)
- [ ] Object type definitions
- [ ] Type aliases
- [ ] Phantom types for type safety
- [ ] Polymorphic variant usage

#### external_decl_tests.ml
**TODO:** Test external C function declarations

Coverage areas:
- [ ] External function naming (ml_gtk_xxx)
- [ ] External function signatures match C stubs
- [ ] Parameter type conversions
- [ ] Return type conversions
- [ ] Nullable type handling (option types)
- [ ] Error handling (result types)

#### signature_tests.ml
**TODO:** Test .mli signature generation

Coverage areas:
- [ ] Public API surface
- [ ] Type constraints in signatures
- [ ] Documentation comments
- [ ] Function signatures match implementation
- [ ] Abstract types vs concrete types
- [ ] Module type definitions

#### edge_cases.ml
**TODO:** Test ML-specific edge cases

Coverage areas:
- [ ] Empty modules
- [ ] Name collisions with OCaml keywords
- [ ] Very long type names
- [ ] Complex nested types
- [ ] Circular type dependencies

### Testing Infrastructure

**Status: üöß IN PROGRESS**

- **ml_ast_helpers.ml** - ‚úÖ Wrapper around OCaml `compiler-libs` for parsing and inspecting ML/MLI files
  - Uses `Parsetree`, `Parse`, `Asttypes` from OCaml compiler
  - Functions for finding type declarations, externals, value declarations
  - AST node inspection and conversion utilities
- **ml_validation.ml** - ‚úÖ High-level validation helpers for common patterns
  - Polymorphic variant validation
  - External declaration validation
  - Type compatibility checking
  - Function signature validation

### Example: Testing with OCaml AST

**Testing a type definition:**
```ocaml
let test_widget_hierarchy_type () =
  let ctx = Helpers.create_test_context () in

  (* Generate ML interface for Button (inherits from Widget) *)
  let ml_code = Gir_gen_lib.Generate.Ml_interface.generate_type_definition
    ~ctx ~class_name:"Button" ~parent_chain:["Widget"] () in

  (* Parse using OCaml's built-in parser *)
  let ast = Ml_ast_helpers.parse_implementation ml_code in

  (* Find the type declaration for 't' *)
  let type_decl = Ml_ast_helpers.find_type_declaration ast "t" in

  (* Validate it's a polymorphic variant with correct tags *)
  Ml_validation.assert_polymorphic_variant type_decl;
  Ml_validation.assert_has_variant_tag type_decl "`button";
  Ml_validation.assert_has_variant_tag type_decl "`widget";

  (* Validate it wraps Gobject.obj *)
  Ml_validation.assert_wraps_gobject_obj type_decl
```

**Testing an external declaration:**
```ocaml
let test_external_with_nullable_params () =
  let ctx = Helpers.create_test_context () in
  let meth = {
    method_name = "set_label";
    c_identifier = "gtk_button_set_label";
    return_type = { name = "none"; c_type = None; nullable = false };
    parameters = [
      { param_name = "label";
        param_type = { name = "utf8"; c_type = Some "gchar*"; nullable = true };
        direction = In; (* ... *) }
    ];
    (* ... *)
  } in

  let ml_code = Gir_gen_lib.Generate.Ml_interface.generate_method
    ~ctx ~class_name:"Button" meth in

  let ast = Ml_ast_helpers.parse_implementation ml_code in
  let ext_decl = Ml_ast_helpers.find_external ast "set_label" in

  (* Validate external signature: string option -> unit *)
  Alcotest.(check bool) "First param is string option" true
    (Ml_validation.is_optional_string_param ext_decl 0);

  Alcotest.(check bool) "Return type is unit" true
    (Ml_validation.returns_unit ext_decl);

  (* Validate C function name *)
  Alcotest.(check string) "C identifier" "ml_gtk_button_set_label"
    (Ml_ast_helpers.get_external_c_name ext_decl)
```

---

## Layer 2: Class Generation Tests

**Status: ‚ùå TODO**

**Location:** `class_generation/` (to be created)

### Testing Approach

Class generation tests should use **library-based testing**:

1. Create test context with class hierarchies
2. Call class generator functions directly
3. Parse generated class definitions
4. Validate inheritance, methods, and properties

### Proposed Test Organization

#### class_structure_tests.ml
**TODO:** Test class definition structure

Coverage areas:
- [ ] Class naming conventions
- [ ] Class constructor generation
- [ ] Class method definitions
- [ ] Class field definitions
- [ ] Virtual methods
- [ ] Private vs public methods

#### inheritance_tests.ml
**TODO:** Test class inheritance hierarchy

Coverage areas:
- [ ] Single inheritance
- [ ] Multiple interface implementation
- [ ] Method overriding
- [ ] Super calls
- [ ] Abstract base classes
- [ ] Interface satisfaction
- [ ] Coercion functions

#### method_dispatch_tests.ml
**TODO:** Test method dispatch mechanism

Coverage areas:
- [ ] Instance methods
- [ ] Class methods
- [ ] Static methods
- [ ] Method name resolution
- [ ] Parameter passing to underlying C stubs
- [ ] Return value conversion
- [ ] Method chaining

#### property_accessor_tests.ml
**TODO:** Test property accessor generation

Coverage areas:
- [ ] Property getter methods
- [ ] Property setter methods
- [ ] Read-only properties
- [ ] Write-only properties
- [ ] Computed properties
- [ ] Property type conversions
- [ ] Property documentation

#### edge_cases.ml
**TODO:** Test class-specific edge cases

Coverage areas:
- [ ] Empty classes (no methods)
- [ ] Classes with only static methods
- [ ] Deep inheritance hierarchies
- [ ] Diamond inheritance problems
- [ ] Name conflicts in inheritance
- [ ] Abstract classes with no concrete implementation

### Testing Infrastructure Needed

- Extend **ml_parser.ml** to handle class syntax
- Extend **ml_ast.ml** with class-specific AST nodes
- Add class validation helpers to **ml_validation.ml**

---

## Integration Tests

**Status: ‚úÖ PARTIALLY IMPLEMENTED**

**Location:** `integration/`

### Testing Approach

Integration tests validate the **full pipeline** from GIR XML to complete generated code:

1. Generate full GIR XML files
2. Run main.exe to produce complete output
3. Validate all generated files (.ml, .mli, .c)
4. Slower but tests full integration

**Example:**
```ocaml
let test_record_support () =
  create_gir_file test_gir record_gir;
  let exit_code = run_gir_gen test_gir output_dir in
  assert_true "Should succeed" (exit_code = 0);

  let c_content = read_file (stub_c_file output_dir "RecordUser") in
  assert_contains "Should use record macro" c_content "Val_GtkTestRecord"
```

### Current Integration Tests

‚úÖ **Implemented:**
- `properties.ml` - Property getter/setter generation (3/3 passing)
- `signals.ml` - Signal handling (1/1 passing)
- `enums.ml` - Enum and bitfield generation (5/5 passing)
- `records.ml` - Record type integration (1/1 passing)
- `core.ml` - Core integration tests

‚ùå **Needed:**
- [ ] Full class hierarchy integration tests
- [ ] Complex type dependency resolution
- [ ] Real GTK GIR file validation
- [ ] Cross-module dependencies
- [ ] Complete namespace generation

---

## Writing New Tests

### Adding a C Stub Test (Layer 0)

1. **Choose the appropriate test file** in `c_stubs/` (or create a new one)

2. **Create test context and data structures:**
```ocaml
let test_my_feature () =
  let ctx = Helpers.create_test_context () in
  let meth = {
    method_name = "my_method";
    c_identifier = "gtk_widget_my_method";
    return_type = { name = "gint"; c_type = Some "gint"; nullable = false };
    parameters = [];
    doc = None;
    throws = false;
    get_property = None;
    set_property = None;
  } in
```

3. **Generate C code:**
```ocaml
  let c_code = Gir_gen_lib.Generate.C_stubs.generate_c_method
    ~ctx ~c_type:"GtkWidget" meth "Widget" in
```

4. **Parse and validate:**
```ocaml
  let functions = C_parser.parse_c_code c_code in
  let func = Option.get (C_ast.find_function functions "ml_gtk_widget_my_method") in

  Alcotest.(check bool) "Should call C function" true
    (C_validation.calls_c_function func "gtk_widget_my_method")
```

5. **Register the test:**
```ocaml
let tests = [
  Alcotest.test_case "My feature" `Quick test_my_feature;
  (* ... other tests ... *)
]
```

### Adding an ML Generation Test (Layer 1)

**TODO:** Document once ML parser infrastructure is implemented

Proposed approach:
1. Create test context with type definitions
2. Call ML generator functions
3. Parse generated .ml/.mli files
4. Validate module structure and types

### Adding a Class Generation Test (Layer 2)

**TODO:** Document once class generation testing is implemented

Proposed approach:
1. Create test context with class hierarchy
2. Call class generator functions
3. Parse generated class definitions
4. Validate inheritance and methods

### Adding an Integration Test

1. **Create GIR XML file:**
```ocaml
let test_my_integration () =
  let gir_content = {|
    <class name="MyWidget" c:type="GtkMyWidget" parent="GtkWidget">
      <method name="set_value" c:identifier="gtk_my_widget_set_value">
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
    </class>
  |} in
  create_gir_file "MyTest.gir" (wrap_namespace gir_content);
```

2. **Run generator:**
```ocaml
  let exit_code = run_gir_gen "MyTest.gir" output_dir in
  assert_true "Generator should succeed" (exit_code = 0);
```

3. **Validate generated files:**
```ocaml
  let c_file = stub_c_file output_dir "MyWidget" in
  let c_content = read_file c_file in
  assert_contains "Should generate C stub" c_content "ml_gtk_my_widget_set_value";

  let ml_file = ml_file output_dir "MyWidget" in
  let ml_content = read_file ml_file in
  assert_contains "Should generate ML function" ml_content "external set_value";
```

### Adding Record Type Tests

When testing record types (opaque or non-opaque):

1. **Create the record structure:**
```ocaml
let test_record = {
  Gir_gen_lib.Types.record_name = "TestRecord";
  c_type = "GtkTestRecord";
  glib_type_name = Some "GtkTestRecord";
  glib_get_type = Some "gtk_test_record_get_type";
  fields = [
    {
      field_name = "width";
      field_type = Some { name = "gint"; c_type = Some "gint"; nullable = false };
      readable = true;
      writable = false;
      field_doc = None;
    }
  ];
  constructors = [];
  methods = [];
  c_symbol_prefix = None;
  disguised = false;  (* true for opaque records *)
  opaque = false;     (* true for opaque records *)
  record_doc = None;
} in
```

2. **Add record to context:**
```ocaml
let ctx = { ctx with records = [test_record] } in
```

3. **Test return types and parameters as shown in examples above**

### Debugging Generated Code

Use `Helpers.log_generated_c_code` to inspect generated C:

```ocaml
Helpers.log_generated_c_code "test description" c_code;
```

This prints the generated C code to test output when running with `-v` flag:

```bash
dune runtest src/tools/test_gir_gen -- -v
```

### Common Testing Patterns

**Testing type conversions:**
```ocaml
(* Check for Val_GtkWidget usage *)
Alcotest.(check bool) "Uses Val_GtkWidget" true
  (C_validation.validates_gtk_constructor func "GtkWidget")
```

**Testing function calls:**
```ocaml
(* Verify C function is called *)
Alcotest.(check bool) "Calls gtk_button_set_label" true
  (C_validation.calls_c_function func "gtk_button_set_label")
```

**Testing parameter counts:**
```ocaml
let param_count = C_ast.get_param_count func in
Alcotest.(check int) "Has 2 parameters" 2 param_count
```

**Testing variable declarations:**
```ocaml
let var_decls = C_ast.get_var_decls func in
Alcotest.(check bool) "Declares obj variable" true
  (List.exists (fun (name, _, _) -> name = "obj") var_decls)
```

---

## Test Results & Coverage

### Overall Test Summary

**Total: 85 tests**
- **85 passing ‚úì** (100% pass rate)

All previously failing tests have been resolved. See `FAILING_TESTS_ANALYSIS.md` for historical analysis.

### C Stub Generation (Layer 0) - Detailed Coverage

#### c_stubs_tests.ml - Basic Generation & Record Types ‚úì (16/16)

**Constructor Tests:**
- [x] Simple constructor (0 params) ‚úì
- [x] Constructor with parameters ‚úì
- [x] Constructor with 6+ params (bytecode/native split) ‚úì

**Method Tests:**
- [x] Simple method (void return) ‚úì
- [x] Method with return value ‚úì

**Type Validation Tests:**
- [x] Constructor uses correct type conversion ‚úì
- [x] Method calls underlying C function ‚úì
- [x] Variable declarations are parsed ‚úì
- [x] Parameter flow to return value ‚úì
- [x] Bytecode calls native function ‚úì

**Record Type Tests:**
- [x] Non-opaque record return type ‚úì
- [x] Non-opaque record parameter ‚úì
- [x] Opaque record return type ‚úì
- [x] Opaque record parameter ‚úì
- [x] Nullable record return type ‚úì
- [x] Nullable record parameter ‚úì

#### nullable_tests.ml - Nullable Handling ‚úì (5/5)
- [x] Nullable string parameter (String_option_val) ‚úì
- [x] Non-nullable parameter validation ‚úì
- [x] Nullable return value ‚úì
- [x] Multiple nullable parameters ‚úì
- [x] Nullable parameter count ‚úì

#### error_handling_tests.ml - Error Handling ‚úì (6/6)
- [x] Method with throws=true declares GError ‚úì
- [x] Error handling uses Res_Ok/Res_Error ‚úì
- [x] Error is passed by reference (&error) ‚úì
- [x] Error is properly initialized to NULL ‚úì
- [x] Complete error handling infrastructure ‚úì
- [x] Constructor with throws ‚úì

#### out_params_tests.ml - Out/InOut Parameters ‚úì (6/6)
- [x] Simple out parameter declaration ‚úì
- [x] Out parameter passed by reference ‚úì
- [x] Out parameter with return value ‚úì
- [x] InOut parameter ‚úì
- [x] Multiple out parameters ‚úì
- [x] Out param not in OCaml input ‚úì

#### type_conversion_tests.ml - Type Conversions ‚úì (9/9)
- [x] gboolean to bool conversion ‚úì
- [x] gint to int conversion ‚úì
- [x] gdouble to float conversion ‚úì
- [x] utf8 string conversion (String_val/caml_copy_string) ‚úì
- [x] utf8 string parameter conversion ‚úì
- [x] Object type conversion (Val_GtkWidget) ‚úì
- [x] Enum type conversion ‚úì
- [x] gboolean parameter conversion ‚úì
- [x] Multiple type conversions ‚úì

### Integration Tests - Coverage

‚úÖ **Completed:**
- [x] Property getters (GValue handling) ‚úì
- [x] Property setters (GValue handling) ‚úì
- [x] Enum and bitfield generation ‚úì
- [x] Signal handling ‚úì
- [x] Record types (opaque and non-opaque) ‚úì
- [x] Nullable record types ‚úì
- [x] Edge cases (empty classes, etc.) ‚úì

### Coverage Gaps

#### C Stub Generation (Layer 0)
- [ ] Static methods (no self parameter)
- [ ] Varargs handling
- [ ] Default parameter values
- [ ] Transfer ownership annotations
- [ ] Callback parameters
- [ ] Array length parameters

#### ML Generation (Layer 1)
- [ ] Module structure validation
- [ ] Type definition validation
- [ ] External declaration validation
- [ ] Signature (.mli) validation

#### Class Generation (Layer 2)
- [ ] Class structure validation
- [ ] Inheritance hierarchy validation
- [ ] Method dispatch validation
- [ ] Property accessor validation

#### Integration
- [ ] Full class hierarchy integration tests
- [ ] Complex type dependency resolution
- [ ] Real GTK GIR file validation
- [ ] Cross-module dependencies

---

## Best Practices

### DO:

‚úÖ Use library-based tests for unit testing individual features
‚úÖ Use integration tests for end-to-end validation
‚úÖ Test both success and failure cases
‚úÖ Test edge cases (nullable, empty lists, etc.)
‚úÖ Add descriptive test names and comments
‚úÖ Log generated code when debugging
‚úÖ Update this document when adding new tests
‚úÖ Organize tests into appropriate subdirectories

### DON'T:

‚ùå Rely on parser for multi-line if/else (known limitation)
‚ùå Test full C compilation (out of scope)
‚ùå Create temporary files in library-based tests
‚ùå Hard-code file paths (use helper functions)
‚ùå Skip return value checks (`Option.get` is acceptable in tests)

---

## Future Extensions

### Layer 0: C Stub Generation
- [ ] Array parameter handling with length parameters
- [ ] Callback parameter handling
- [ ] Transfer ownership annotations
- [ ] Varargs handling
- [ ] Default parameter values
- [ ] Static methods (no self parameter)

### Layer 1: ML File Generation
- [ ] Complete ML parser implementation
- [ ] Module structure validation
- [ ] Type definition validation
- [ ] External declaration validation
- [ ] Signature validation

### Layer 2: Class Generation
- [ ] Class generation testing framework
- [ ] Inheritance validation
- [ ] Method dispatch validation
- [ ] Property accessor validation

### Integration Testing
- [ ] Full integration tests with real GTK GIR files
- [ ] Cross-module dependency testing
- [ ] Performance benchmarks for generator
- [ ] Regression test suite with real-world examples

---

## References

- **GObject Introspection Specification**: https://gi.readthedocs.io/
- **GTK Documentation**: https://docs.gtk.org/
- **OCaml FFI Documentation**: https://ocaml.org/manual/intfc.html
- **Alcotest Documentation**: https://github.com/mirage/alcotest
