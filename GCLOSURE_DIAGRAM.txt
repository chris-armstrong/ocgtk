# GClosure Memory Layout and Cleanup Race Condition

## Normal Operation (Everything Works)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  OCaml Heap                GLib Memory                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  [OCaml Closure]  â†â”€â”€â”€â”€â”€â”€â”                                  â”‚
â”‚   (callback code)         â”‚                                  â”‚
â”‚                           â”‚                                  â”‚
â”‚  Global Roots List:       â”‚                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚                                  â”‚
â”‚  â”‚ &closure->dataâ”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚          â”‚                      â”‚
â”‚                           â”‚          â†“                      â”‚
â”‚                           â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚                           â”‚    â”‚   GClosure      â”‚          â”‚
â”‚                           â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”‚
â”‚                           â”‚    â”‚ data: â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚                           â”‚    â”‚   (points to)   â”‚      â”‚   â”‚
â”‚                           â”‚    â”‚ marshal: ...    â”‚      â”‚   â”‚
â”‚                           â”‚    â”‚ ref_count: 1    â”‚      â”‚   â”‚
â”‚                           â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚   â”‚
â”‚                           â”‚                             â”‚   â”‚
â”‚                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                               â”‚
â”‚  During normal operation:                                    â”‚
â”‚  1. GC scans global roots â†’ follows &closure->data          â”‚
â”‚  2. Finds OCaml callback â†’ marks it as reachable            â”‚
â”‚  3. Callback stays alive â†’ âœ… Everything works              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Program Exit - Race Condition Scenario

### Scenario A: Safe Order (Lucky)

```
Step 1: GClosure invalidate called by GLib
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  notify_destroy() called:                                    â”‚
â”‚  1. caml_remove_global_root(&closure->data)                 â”‚
â”‚  2. Global roots list updated                                â”‚
â”‚                                                               â”‚
â”‚  Global Roots List:                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                            â”‚
â”‚  â”‚ (empty)      â”‚  â† Root removed âœ…                         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                            â”‚
â”‚                                                               â”‚
â”‚  GClosure still valid (ref_count going to 0)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: GClosure freed
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  g_closure_unref() â†’ ref_count = 0 â†’ memory freed           â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                         â”‚
â”‚  â”‚   (freed)       â”‚  â† GClosure gone                       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 3: OCaml GC runs
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  GC scans global roots:                                      â”‚
â”‚  - List is empty                                             â”‚
â”‚  - Nothing to scan                                           â”‚
â”‚  - âœ… No crash!                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Scenario B: Crash Order (What Actually Happens)

```
Step 1: GClosure freed first (GLib cleanup)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  During program exit, GLib cleans up:                        â”‚
â”‚  g_closure_unref() called â†’ ref_count = 0                   â”‚
â”‚                                                               â”‚
â”‚  Global Roots List:                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                            â”‚
â”‚  â”‚ &closure->dataâ”‚ â† Still registered! âš ï¸                    â”‚
â”‚  â”‚   = 0x336518  â”‚                                           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                            â”‚
â”‚         â”‚                                                     â”‚
â”‚         â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                         â”‚
â”‚  â”‚  FREED MEMORY   â”‚ â† GClosure already freed âŒ            â”‚
â”‚  â”‚  (garbage)      â”‚                                         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: OCaml GC tries to scan global roots
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  caml_scan_global_roots():                                   â”‚
â”‚    for each root in global_roots_list:                       â”‚
â”‚      value = *root;  // Dereference &closure->data          â”‚
â”‚         â†“                                                     â”‚
â”‚         â†“  Tries to access 0x336518                         â”‚
â”‚         â†“                                                     â”‚
â”‚         â†“  But that memory is FREED!                         â”‚
â”‚         â†“                                                     â”‚
â”‚         ğŸ’¥ SIGSEGV - Bad permissions for mapped region      â”‚
â”‚                                                               â”‚
â”‚  Valgrind output:                                            â”‚
â”‚    Process terminating with signal 11 (SIGSEGV)             â”‚
â”‚    Bad permissions for mapped region at address 0x336518    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Why lablgtk3 Doesn't Crash (Usually)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  lablgtk3 (OCaml 4.14) vs lablgtk4 (OCaml 5.3)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  OCaml 4.14 Exit Sequence:                                  â”‚
â”‚  1. Run finalization code                                    â”‚
â”‚  2. GLib cleanup â†’ notify_destroy() â†’ unregister roots      â”‚
â”‚  3. Final GC (sees empty root list)                         â”‚
â”‚  â””â”€> Usually safe order (Scenario A)                        â”‚
â”‚                                                               â”‚
â”‚  OCaml 5.3 Exit Sequence:                                   â”‚
â”‚  1. Multicore runtime shutdown                               â”‚
â”‚  2. GC triggered early/often                                 â”‚
â”‚  3. GLib cleanup may happen before/during/after             â”‚
â”‚  â””â”€> Race condition (Scenario B happens more often)         â”‚
â”‚                                                               â”‚
â”‚  Key Difference:                                             â”‚
â”‚  - OCaml 5.x has different GC implementation                â”‚
â”‚  - More aggressive collection                                â”‚
â”‚  - Different shutdown timing                                 â”‚
â”‚  - Same bug, different manifestation                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Our Solution: Leak Global Roots

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Modified Approach (lablgtk4):                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  CAMLprim value ml_g_closure_new(value callback)            â”‚
â”‚  {                                                            â”‚
â”‚      GClosure *closure = g_closure_new_simple(...);          â”‚
â”‚      caml_register_global_root(&closure->data);              â”‚
â”‚                                                               â”‚
â”‚      // âŒ DO NOT add invalidate notifier                    â”‚
â”‚      // g_closure_add_invalidate_notifier(...);             â”‚
â”‚                                                               â”‚
â”‚      g_closure_set_marshal(...);                             â”‚
â”‚      return Val_GClosure_sink(closure);                      â”‚
â”‚  }                                                            â”‚
â”‚                                                               â”‚
â”‚  Result:                                                      â”‚
â”‚  - Global root NEVER unregistered                            â”‚
â”‚  - GClosure may be freed                                     â”‚
â”‚  - But GC won't crash accessing it                           â”‚
â”‚                                                               â”‚
â”‚  Wait... why doesn't it crash?                               â”‚
â”‚                                                               â”‚
â”‚  Because:                                                     â”‚
â”‚  1. Global root still points to freed memory                 â”‚
â”‚  2. BUT: At program exit, the value it points to is         â”‚
â”‚     already marked/scanned, or GC finishes before access    â”‚
â”‚  3. The race window is smaller                               â”‚
â”‚                                                               â”‚
â”‚  This is still not perfect, but:                             â”‚
â”‚  - test_gdk: âœ… Clean exit                                   â”‚
â”‚  - test_all_enums: âœ… Clean exit                             â”‚
â”‚  - test_gobject: âŒ Still crashes (more closures = more      â”‚
â”‚                       global roots = bigger race window)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## The Real Fix (Future Work)

```
Allocate separate storage for global root:

CAMLprim value ml_g_closure_new(value callback)
{
    // Allocate stable storage NOT inside GClosure
    value *root = malloc(sizeof(value));
    *root = callback;
    caml_register_global_root(root);

    // Store pointer to the allocated root
    GClosure *closure = g_closure_new_simple(sizeof(GClosure), root);

    g_closure_add_invalidate_notifier(closure, root, notify_destroy);
    ...
}

static void notify_destroy(gpointer data, GClosure *closure)
{
    value *root = (value*)data;  // From notifier data
    caml_remove_global_root(root);
    free(root);  // Free the allocated storage
}

Problem: free(root) can STILL race with GC scanning!
The only true fix is using OCaml-aware GLib integration or domain-local storage.
```
